{"remainingRequest":"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/babel-loader/lib/index.js!/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/eslint-loader/index.js??ref--13-0!/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/src/store/modules/vuexStore.js","dependencies":[{"path":"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/src/store/modules/vuexStore.js","mtime":1588271945807},{"path":"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/cache-loader/dist/cjs.js","mtime":1586229982811},{"path":"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _toConsumableArray from \"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/@babel/runtime/helpers/builtin/es6/toConsumableArray\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.set\";\nimport _objectWithoutProperties from \"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/@babel/runtime/helpers/builtin/es6/objectWithoutProperties\";\nimport _objectSpread from \"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/@babel/runtime/helpers/builtin/es6/objectSpread\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/node_modules/@babel/runtime/helpers/builtin/es6/asyncToGenerator\";\nimport axios from \"axios\";\nimport { apiBaseUrl } from \"../baseUrl\";\nvar state = {\n  // The keys defined below represents the initial state of our data the first time our app loads\n  user: {\n    userObj: {},\n    followers: [],\n    followed: [],\n    polls: [],\n    likes: []\n  },\n  userID: null,\n  error: [],\n  status: \"\",\n  token: localStorage.getItem(\"token\") || \"\",\n  loggedIn: false,\n  Polls: [],\n  trendingPolls: [],\n  SinglePoll: {\n    id: \"\",\n    pub_date: \"\",\n    question: \"\",\n    choices: [{}],\n    poller_username: \"\",\n    choice_type: \"\",\n    expire_date: \"\",\n    slug_field: \"\",\n    poll_has_been_bookmarked: \"\",\n    poll_has_been_liked: \"\",\n    total_likes: \"\",\n    vote_count: \"\"\n  }\n};\n/* getters pull updated value from our state data's and they are then called by the components that needs them to\npresent data to the user(s) */\n\nvar getters = {\n  allPolls: function allPolls(state) {\n    return state.Polls;\n  },\n  pollsTrending: function pollsTrending(state) {\n    return state.trendingPolls;\n  },\n  isLoggedIn: function isLoggedIn(state) {\n    return !!state.token;\n  },\n  authStatus: function authStatus(state) {\n    return state.status;\n  },\n  getUser: function getUser(state) {\n    return state.user;\n  },\n  numberOfFollowers: function numberOfFollowers(state) {\n    return state.user.followers.length;\n  },\n  numberOfFollowed: function numberOfFollowed(state) {\n    return state.user.followed.length;\n  },\n  numberOfPolls: function numberOfPolls(state) {\n    return state.user.polls.length;\n  },\n  getToken: function getToken(state) {\n    return state.token;\n  },\n  getuserID: function getuserID(state) {\n    return state.userID;\n  },\n  isAuthenticated: function isAuthenticated(state) {\n    return state.loggedIn;\n  },\n  getSinglePoll: function getSinglePoll(state) {\n    return state.SinglePoll;\n  }\n}; // actions are mostly responsible for performing CRUD operations as allowed on the API endpoints being called\n\nvar actions = {\n  // This is used to make a post request to the login API, where payload is the data that was passed when the\n  // login action was dispatched from the Login component\n  login: function login(_ref, payload) {\n    var commit = _ref.commit,\n        dispatch = _ref.dispatch;\n    return new Promise(function (resolve, reject) {\n      commit(\"auth_request\");\n      axios({\n        url: \"\".concat(apiBaseUrl.baseRoute, \"/users/login/\"),\n        data: payload,\n        method: \"POST\"\n      }).then(function (response) {\n        var token = response.data.token;\n        var user = response.data.pk;\n        localStorage.setItem(\"token\", token);\n        axios.defaults.headers.common[\"Authorization\"] = token; // we call a mutation to commit our data\n\n        commit(\"auth_success\", {\n          token: token,\n          user: user\n        }); // Here we are dispatching the getUser action since we want to get the loggedIn users profile\n        // along with the data being sent back by the login action\n\n        dispatch(\"getUser\", user);\n        resolve(response);\n      }).catch(function (err) {\n        commit(\"auth_error\"); // localStorage.removeItem(\"token\");\n\n        reject(err);\n      });\n    });\n  },\n  logout: function logout(_ref2) {\n    var commit = _ref2.commit;\n    // This action is used to logout a user\n    return new Promise(function (resolve) {\n      commit(\"logout\");\n      localStorage.removeItem(\"token\");\n      delete axios.defaults.headers.common[\"Authorization\"];\n      resolve();\n    });\n  },\n  // This action is used to send a post request to the backend API to register a new user\n  register: function () {\n    var _register = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(_ref3, payload) {\n      var commit, _ref4, response;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              commit = _ref3.commit;\n              _context.next = 3;\n              return axios({\n                url: \"\".concat(apiBaseUrl.baseRoute, \"/users/signup/\"),\n                data: payload,\n                method: \"POST\"\n              });\n\n            case 3:\n              _ref4 = _context.sent;\n              response = _ref4.response;\n              // We call a mutation to commit our reponse data\n              commit(\"registration_success\", response);\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function register(_x, _x2) {\n      return _register.apply(this, arguments);\n    };\n  }(),\n  // register({ commit, dispatch }, payload){\n  // \treturn new Promise((resolve, reject) => {\n  // \t\tcommit(\"auth_request\");\n  // \t\taxios({\n  // \t\t\turl: `${apiBaseUrl.baseRoute}/users/signup/`,\n  // \t\t\tdata: payload,\n  // \t\t\tmethod: \"POST\"\n  // \t\t})\n  // \t\t\t.then(response => {\n  // \t\t\t\t// const token = response.data.token;\n  // \t\t\t\tconst username = response.data.username;\n  // \t\t\t\tlocalStorage.setItem(\"token\", token);\n  // \t\t\t\taxios.defaults.headers.common[\"Authorization\"] = token;\n  // \t\t\t\t// we call a mutation to commit our data\n  // \t\t\t\tcommit(\"auth_success\", { token, user });\n  // \t\t\t\t// Here we are dispatching the getUser action since we want to get the loggedIn users profile\n  // \t\t\t\t// along with the data being sent back by the login action\n  // \t\t\t\tdispatch(\"getUser\", user);\n  // \t\t\t\tresolve(response);\n  // \t\t\t})\n  // \t\t\t.catch(err => {\n  // \t\t\t\tcommit(\"auth_error\");\n  // \t\t\t\t// localStorage.removeItem(\"token\");\n  // \t\t\t\treject(err);\n  // \t\t\t});\n  // \t});\n  // },\n  // This action is used to make a get request to the API endpoint so we can fetch data to update our\n  // current loggedIn user profile\n  getUser: function getUser(_ref5, id) {\n    var commit = _ref5.commit,\n        getters = _ref5.getters;\n    // config is used to set the authorization by getting the token of the the logged in user\n    var config = {\n      headers: {\n        Authorization: \"Token \".concat(getters.getToken) // \"Content-Type\": \"application/json\"\n\n      }\n    };\n    axios.get(\"\".concat(apiBaseUrl.baseRoute, \"/userprofile/\").concat(id, \"/\"), config).then(function (response) {\n      console.log(response.data);\n      axios.defaults.headers.common[\"Authorization\"] = config; // We call a mutation to commit our response data\n\n      commit(\"fetch_users\", response.data);\n    });\n  },\n  // This action is used to get all available polls from the server\n  getPolls: function () {\n    var _getPolls = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee2(_ref6) {\n      var commit, response;\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              commit = _ref6.commit;\n              _context2.next = 3;\n              return axios.get(\"\".concat(apiBaseUrl.baseRoute, \"/polls/polls/\"));\n\n            case 3:\n              response = _context2.sent;\n              // We call a mutation to commit our response data\n              commit(\"SUCCESS\", response.data);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    return function getPolls(_x3) {\n      return _getPolls.apply(this, arguments);\n    };\n  }(),\n  // This action is used to get individual polls from the server\n  getSinglePoll: function () {\n    var _getSinglePoll = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee3(_ref7, id) {\n      var commit, getters, config;\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              commit = _ref7.commit, getters = _ref7.getters;\n              console.log(\"Getting Single ID from actions\", id); // config is used to set the authorization by getting the token of the the logged in user\n\n              config = {\n                headers: {\n                  Authorization: \"Token \".concat(getters.getToken) // \"Content-Type\": \"application/json\"\n\n                }\n              };\n              axios.get(\"\".concat(apiBaseUrl.baseRoute, \"/polls/polls/\").concat(id, \"/\"), config).then(function (response) {\n                axios.defaults.headers.common[\"Authorization\"] = config; // We call a mutation to commit our response data\n\n                commit(\"SINGLE_POLL\", response.data);\n              });\n\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    return function getSinglePoll(_x4, _x5) {\n      return _getSinglePoll.apply(this, arguments);\n    };\n  }(),\n  // this action is used to make a post request to create a new poll\n  newPoll: function newPoll(_ref8, payload) {\n    var commit = _ref8.commit,\n        getters = _ref8.getters;\n    var config = {\n      headers: {\n        // \"Content-Type\": \"application/json\",\n        Authorization: \"Token \".concat(getters.getToken)\n      }\n    };\n    axios.post(\"\".concat(apiBaseUrl.baseRoute, \"/polls/create-polls/\"), payload, config).then(function (response) {\n      console.log(\"Response from poll request form\", response.data);\n      axios.defaults.headers.common[\"Authorization\"] = config; // We call a mutation to commit our response data\n\n      commit(\"SUCCESS\", response.data);\n    });\n  },\n  // this action is used to make a post request to like an existing poll\n  likePoll: function likePoll(_ref9, payload) {\n    var commit = _ref9.commit,\n        getters = _ref9.getters;\n    var config = {\n      headers: {\n        // \"Content-Type\": \"application/json\",\n        Authorization: \"Token \".concat(getters.getToken)\n      }\n    };\n    axios.post(\"\".concat(apiBaseUrl.baseRoute, \"/userprofile/like-poll/\"), payload, config).then(function (response) {\n      axios.defaults.headers.common[\"Authorization\"] = config; // We call a mutation to commit our response data\n\n      commit(\"SUCCESS\", response.data);\n    });\n  },\n  // This action is used to make a post request for voting on a particular choice.\n  voteChoice: function voteChoice(_ref10, payload) {\n    var commit = _ref10.commit,\n        getters = _ref10.getters;\n\n    var _payload = _objectSpread({}, payload),\n        poll = _payload.poll,\n        choice = _payload.choice;\n\n    var config = {\n      headers: {\n        Authorization: \"Token \".concat(getters.getToken)\n      }\n    };\n    axios.post(\"\".concat(apiBaseUrl.baseRoute, \"/polls/vote/\").concat(poll, \"/\").concat(choice, \"/\"), payload, config).then(function (response) {\n      axios.defaults.headers.common[\"Authorization\"] = config; // We call a mutation to commit our response data\n\n      commit(\"SUCCESS\", response.data);\n    });\n  },\n  // This action is used to make a post request to bookmark a poll\n  bookmarkPoll: function bookmarkPoll(_ref11, payload) {\n    var commit = _ref11.commit,\n        getters = _ref11.getters;\n    var config = {\n      headers: {\n        Authorization: \"Token \".concat(getters.getToken)\n      }\n    };\n    axios.post(\"\".concat(apiBaseUrl.baseRoute, \"/userprofile/bookmark-poll/\"), payload, config).then(function (response) {\n      axios.defaults.headers.common[\"Authorization\"] = config; // We call a mutation to commit our response data\n\n      commit(\"SUCCESS\", response.data);\n    });\n  },\n  // This action is used to make a get request to get list of trendingPolls from the server\n  getTrendingPolls: function getTrendingPolls(_ref12) {\n    var commit = _ref12.commit,\n        getters = _ref12.getters;\n    var config = {\n      headers: {\n        Authorization: \"Token \".concat(getters.getToken)\n      }\n    };\n    axios.get(\"\".concat(apiBaseUrl.baseRoute, \"/trending/polls/\"), config).then(function (response) {\n      axios.defaults.headers.common[\"Authorization\"] = config; // We call a mutation to commit our response data\n\n      commit(\"TRENDING_POLLS\", response.data);\n    });\n  },\n  // getTrendingFeeds({ commit, getters }) {\n  // \tlet config = {\n  // \t\theaders: {\n  // \t\t\tAuthorization: `Token ${getters.getToken}`\n  // \t\t\t// \"Content-Type\": \"application/json\"\n  // \t\t}\n  // \t};\n  // \taxios\n  // \t\t.get(`${apiBaseUrl.baseRoute}/trending/feed/`, config)\n  // \t\t.then(response => {\n  // \t\t\tconsole.log(response.data, \"FROM TRENDING Feeds\");\n  // \t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n  // \t\t\tcommit(\"SUCCESS\", response.data);\n  // \t\t});\n  // },\n  // This action is used to make a post request to search for an existing poll\n  searchPolls: function searchPolls(_ref13, payload) {\n    var commit = _ref13.commit,\n        getters = _ref13.getters;\n    var config = {\n      headers: {\n        Authorization: \"Token \".concat(getters.getToken)\n      }\n    };\n    axios.get(\"\".concat(apiBaseUrl.baseRoute, \"/search/poll/?search=\") + payload, config).then(function (response) {\n      console.log(response.data, \"SEARCH RESULT\");\n      axios.defaults.headers.common[\"Authorization\"] = config; // We call a mutation to commit our response data\n\n      commit(\"SEARCH_RESULT\", response.data);\n    });\n  }\n}; // These are used to update our state depending on the response gotten when an action is dispatched\n\nvar mutations = {\n  auth_request: function auth_request(state) {\n    state.status = \"loading\";\n  },\n  registration_success: function registration_success(state, payload) {// const { username, email, ...profile} = payload\n    // state.user\n  },\n  auth_success: function auth_success(state, payload) {\n    var token = payload.token,\n        pk = payload.pk;\n    state.status = \"success\";\n    state.loggedIn = true;\n    state.token = token;\n    state.userID = pk;\n  },\n  auth_error: function auth_error(state, payload) {\n    var data = payload.data;\n    state.status = \"error\";\n    state.isLoading = false;\n    state.error = data;\n  },\n  logout: function logout(state) {\n    state.status = \"\";\n    state.token = \"\";\n  },\n\n  /* Used to update the states which are perculiar for display data specific to a user or userprofile\n  Since the the payload contains a user object, while destructing the payload, we use spread operator\n  to get the keys in the user object */\n  fetch_users: function fetch_users(state, payload) {\n    var followed = payload.followed,\n        followers = payload.followers,\n        likes = payload.likes,\n        polls = payload.polls,\n        user = _objectWithoutProperties(payload, [\"followed\", \"followers\", \"likes\", \"polls\"]);\n\n    state.user.userObj = user;\n    state.user.followed = followed;\n    state.user.followers = followers;\n    state.user.polls = polls;\n    state.user.likes = likes;\n  },\n  // this simply updates the Polls data in the state with the data coming from the payload\n  SUCCESS: function SUCCESS(state, payload) {\n    return state.Polls = payload;\n  },\n  SINGLE_POLL: function SINGLE_POLL(state, payload) {\n    var id = payload.id,\n        pub_date = payload.pub_date,\n        question = payload.question,\n        poller_username = payload.poller_username,\n        choice_type = payload.choice_type,\n        expire_date = payload.expire_date,\n        slug_field = payload.slug_field,\n        poll_has_been_bookmarked = payload.poll_has_been_bookmarked,\n        poll_has_been_liked = payload.poll_has_been_liked,\n        total_likes = payload.total_likes,\n        vote_count = payload.vote_count,\n        choices = _objectWithoutProperties(payload, [\"id\", \"pub_date\", \"question\", \"poller_username\", \"choice_type\", \"expire_date\", \"slug_field\", \"poll_has_been_bookmarked\", \"poll_has_been_liked\", \"total_likes\", \"vote_count\"]);\n\n    state.SinglePoll.id = id;\n    state.SinglePoll.pub_date = pub_date;\n    state.SinglePoll.question = question;\n    state.SinglePoll.poller_username = poller_username;\n    state.SinglePoll.choice_type = choice_type;\n    state.SinglePoll.expire_date = expire_date;\n    state.SinglePoll.slug_field = slug_field;\n    state.SinglePoll.poll_has_been_bookmarked = poll_has_been_bookmarked;\n    state.SinglePoll.poll_has_been_liked = poll_has_been_liked;\n    state.SinglePoll.total_likes = total_likes;\n    state.SinglePoll.vote_count = vote_count;\n    state.SinglePoll.choices = _objectSpread({}, choices);\n  },\n  TRENDING_POLLS: function TRENDING_POLLS(state, payload) {\n    /* Since we are getting a list of items from the API which contains repeated questions, we filter out\n    this repeated question using javascript Set method and loop over the incoming date to fetch only the\n    questions which we then store in the filteredList variable. Next we use the spread operator on our set of questions,\n    converting it into a list and pass it to the state.trendingPolls to be updated in the state */\n    var filteredList = new Set(payload.map(function (poll) {\n      return poll.question;\n    }));\n    state.trendingPolls = _toConsumableArray(filteredList);\n  }\n};\n/* \n\tGoing forward the config variable can be used as a helper function to avoid repeating same codes whenever\n\tyou want to make a request to an endpoint that is restricted\n\n\tconst config = {\n\t\theaders: {\n\t\t\t: `Token ${getters.getToken}`\n\t\t \t\"Content-Type\": \"application/json\"\n\t\t}\n\t}; \n*/\n\nexport default {\n  state: state,\n  getters: getters,\n  actions: actions,\n  mutations: mutations // config\n\n};",{"version":3,"sources":["/home/baron/Documents/projects/Client/YOUDECIDE/youdecide_vue/src/store/modules/vuexStore.js"],"names":["axios","apiBaseUrl","state","user","userObj","followers","followed","polls","likes","userID","error","status","token","localStorage","getItem","loggedIn","Polls","trendingPolls","SinglePoll","id","pub_date","question","choices","poller_username","choice_type","expire_date","slug_field","poll_has_been_bookmarked","poll_has_been_liked","total_likes","vote_count","getters","allPolls","pollsTrending","isLoggedIn","authStatus","getUser","numberOfFollowers","length","numberOfFollowed","numberOfPolls","getToken","getuserID","isAuthenticated","getSinglePoll","actions","login","payload","commit","dispatch","Promise","resolve","reject","url","baseRoute","data","method","then","response","pk","setItem","defaults","headers","common","catch","err","logout","removeItem","register","config","Authorization","get","console","log","getPolls","newPoll","post","likePoll","voteChoice","poll","choice","bookmarkPoll","getTrendingPolls","searchPolls","mutations","auth_request","registration_success","auth_success","auth_error","isLoading","fetch_users","SUCCESS","SINGLE_POLL","TRENDING_POLLS","filteredList","Set","map"],"mappings":"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","sourcesContent":["import axios from \"axios\";\nimport { apiBaseUrl } from \"../baseUrl\";\n\nconst state = {\n\t// The keys defined below represents the initial state of our data the first time our app loads\n\tuser: {\n\t\tuserObj: {},\n\t\tfollowers: [],\n\t\tfollowed: [],\n\t\tpolls: [],\n\t\tlikes: []\n\t},\n\tuserID: null,\n\terror: [],\n\tstatus: \"\",\n\ttoken: localStorage.getItem(\"token\") || \"\",\n\tloggedIn: false,\n\tPolls: [],\n\ttrendingPolls: [],\n\tSinglePoll: {\n\t\tid: \"\",\n\t\tpub_date: \"\",\n\t\tquestion: \"\",\n\t\tchoices: [{}],\n\t\tpoller_username: \"\",\n\t\tchoice_type: \"\",\n\t\texpire_date: \"\",\n\t\tslug_field: \"\",\n\t\tpoll_has_been_bookmarked: \"\",\n\t\tpoll_has_been_liked: \"\",\n\t\ttotal_likes: \"\",\n\t\tvote_count: \"\"\n\t}\n};\n\n/* getters pull updated value from our state data's and they are then called by the components that needs them to\npresent data to the user(s) */\nconst getters = {\n\tallPolls: state => state.Polls,\n\tpollsTrending: state => state.trendingPolls,\n\tisLoggedIn: state => !!state.token,\n\tauthStatus: state => state.status,\n\tgetUser: state => state.user,\n\tnumberOfFollowers: state => state.user.followers.length,\n\tnumberOfFollowed: state => state.user.followed.length,\n\tnumberOfPolls: state => state.user.polls.length,\n\tgetToken: state => state.token,\n\tgetuserID: state => state.userID,\n\tisAuthenticated: state => state.loggedIn,\n\tgetSinglePoll: state => state.SinglePoll\n};\n\n// actions are mostly responsible for performing CRUD operations as allowed on the API endpoints being called\nconst actions = {\n\t// This is used to make a post request to the login API, where payload is the data that was passed when the\n\t// login action was dispatched from the Login component\n\tlogin({ commit, dispatch }, payload) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tcommit(\"auth_request\");\n\t\t\taxios({\n\t\t\t\turl: `${apiBaseUrl.baseRoute}/users/login/`,\n\t\t\t\tdata: payload,\n\t\t\t\tmethod: \"POST\"\n\t\t\t})\n\t\t\t\t.then(response => {\n\t\t\t\t\tconst token = response.data.token;\n\t\t\t\t\tconst user = response.data.pk;\n\t\t\t\t\tlocalStorage.setItem(\"token\", token);\n\t\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = token;\n\t\t\t\t\t// we call a mutation to commit our data\n\t\t\t\t\tcommit(\"auth_success\", { token, user });\n\t\t\t\t\t// Here we are dispatching the getUser action since we want to get the loggedIn users profile\n\t\t\t\t\t// along with the data being sent back by the login action\n\t\t\t\t\tdispatch(\"getUser\", user);\n\t\t\t\t\tresolve(response);\n\t\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tcommit(\"auth_error\");\n\t\t\t\t\t// localStorage.removeItem(\"token\");\n\t\t\t\t\treject(err);\n\t\t\t\t});\n\t\t});\n\t},\n\n\tlogout({ commit }) {\n\t\t// This action is used to logout a user\n\t\treturn new Promise(resolve => {\n\t\t\tcommit(\"logout\");\n\t\t\tlocalStorage.removeItem(\"token\");\n\t\t\tdelete axios.defaults.headers.common[\"Authorization\"];\n\t\t\tresolve();\n\t\t});\n\t},\n\n\t// This action is used to send a post request to the backend API to register a new user\n\tregister: async ({ commit }, payload) => {\n\t\tlet { response } = await axios({\n\t\t\turl: `${apiBaseUrl.baseRoute}/users/signup/`,\n\t\t\tdata: payload,\n\t\t\tmethod: \"POST\"\n\t\t});\n\t\t// We call a mutation to commit our reponse data\n\t\tcommit(\"registration_success\", response);\n\t},\n\n\t// register({ commit, dispatch }, payload){\n\t// \treturn new Promise((resolve, reject) => {\n\t// \t\tcommit(\"auth_request\");\n\t// \t\taxios({\n\t// \t\t\turl: `${apiBaseUrl.baseRoute}/users/signup/`,\n\t// \t\t\tdata: payload,\n\t// \t\t\tmethod: \"POST\"\n\t// \t\t})\n\t// \t\t\t.then(response => {\n\t// \t\t\t\t// const token = response.data.token;\n\t// \t\t\t\tconst username = response.data.username;\n\t// \t\t\t\tlocalStorage.setItem(\"token\", token);\n\t// \t\t\t\taxios.defaults.headers.common[\"Authorization\"] = token;\n\t// \t\t\t\t// we call a mutation to commit our data\n\t// \t\t\t\tcommit(\"auth_success\", { token, user });\n\t// \t\t\t\t// Here we are dispatching the getUser action since we want to get the loggedIn users profile\n\t// \t\t\t\t// along with the data being sent back by the login action\n\t// \t\t\t\tdispatch(\"getUser\", user);\n\t// \t\t\t\tresolve(response);\n\t// \t\t\t})\n\t// \t\t\t.catch(err => {\n\t// \t\t\t\tcommit(\"auth_error\");\n\t// \t\t\t\t// localStorage.removeItem(\"token\");\n\t// \t\t\t\treject(err);\n\t// \t\t\t});\n\t// \t});\n\t// },\n\n\t// This action is used to make a get request to the API endpoint so we can fetch data to update our\n\t// current loggedIn user profile\n\tgetUser({ commit, getters }, id) {\n\t\t// config is used to set the authorization by getting the token of the the logged in user\n\t\tlet config = {\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Token ${getters.getToken}`\n\t\t\t\t// \"Content-Type\": \"application/json\"\n\t\t\t}\n\t\t};\n\t\taxios\n\t\t\t.get(`${apiBaseUrl.baseRoute}/userprofile/${id}/`, config)\n\t\t\t.then(response => {\n\t\t\t\tconsole.log(response.data);\n\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t\t\t\t// We call a mutation to commit our response data\n\t\t\t\tcommit(\"fetch_users\", response.data);\n\t\t\t});\n\t},\n\n\t// This action is used to get all available polls from the server\n\tasync getPolls({ commit }) {\n\t\tconst response = await axios.get(`${apiBaseUrl.baseRoute}/polls/polls/`);\n\t\t// We call a mutation to commit our response data\n\t\tcommit(\"SUCCESS\", response.data);\n\t},\n\n\t// This action is used to get individual polls from the server\n\tasync getSinglePoll({ commit, getters }, id) {\n\t\tconsole.log(\"Getting Single ID from actions\", id);\n\t\t// config is used to set the authorization by getting the token of the the logged in user\n\t\tlet config = {\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Token ${getters.getToken}`\n\t\t\t\t// \"Content-Type\": \"application/json\"\n\t\t\t}\n\t\t};\n\t\taxios\n\t\t\t.get(`${apiBaseUrl.baseRoute}/polls/polls/${id}/`, config)\n\t\t\t.then(response => {\n\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t\t\t\t// We call a mutation to commit our response data\n\t\t\t\tcommit(\"SINGLE_POLL\", response.data);\n\t\t\t});\n\t},\n\n\t// this action is used to make a post request to create a new poll\n\tnewPoll({ commit, getters }, payload) {\n\t\tlet config = {\n\t\t\theaders: {\n\t\t\t\t// \"Content-Type\": \"application/json\",\n\t\t\t\tAuthorization: `Token ${getters.getToken}`\n\t\t\t}\n\t\t};\n\t\taxios\n\t\t\t.post(`${apiBaseUrl.baseRoute}/polls/create-polls/`, payload, config)\n\t\t\t.then(response => {\n\t\t\t\tconsole.log(\"Response from poll request form\", response.data);\n\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t\t\t\t// We call a mutation to commit our response data\n\t\t\t\tcommit(\"SUCCESS\", response.data);\n\t\t\t});\n\t},\n\n\t// this action is used to make a post request to like an existing poll\n\tlikePoll({ commit, getters }, payload) {\n\t\tlet config = {\n\t\t\theaders: {\n\t\t\t\t// \"Content-Type\": \"application/json\",\n\t\t\t\tAuthorization: `Token ${getters.getToken}`\n\t\t\t}\n\t\t};\n\t\taxios\n\t\t\t.post(`${apiBaseUrl.baseRoute}/userprofile/like-poll/`, payload, config)\n\t\t\t.then(response => {\n\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t\t\t\t// We call a mutation to commit our response data\n\t\t\t\tcommit(\"SUCCESS\", response.data);\n\t\t\t});\n\t},\n\n\t// This action is used to make a post request for voting on a particular choice.\n\tvoteChoice({ commit, getters }, payload) {\n\t\tconst { poll, choice } = { ...payload };\n\t\tlet config = {\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Token ${getters.getToken}`\n\t\t\t}\n\t\t};\n\t\taxios\n\t\t\t.post(\n\t\t\t\t`${apiBaseUrl.baseRoute}/polls/vote/${poll}/${choice}/`,\n\t\t\t\tpayload,\n\t\t\t\tconfig\n\t\t\t)\n\t\t\t.then(response => {\n\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t\t\t\t// We call a mutation to commit our response data\n\t\t\t\tcommit(\"SUCCESS\", response.data);\n\t\t\t});\n\t},\n\n\t// This action is used to make a post request to bookmark a poll\n\tbookmarkPoll({ commit, getters }, payload) {\n\t\tlet config = {\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Token ${getters.getToken}`\n\t\t\t}\n\t\t};\n\t\taxios\n\t\t\t.post(\n\t\t\t\t`${apiBaseUrl.baseRoute}/userprofile/bookmark-poll/`,\n\t\t\t\tpayload,\n\t\t\t\tconfig\n\t\t\t)\n\t\t\t.then(response => {\n\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t\t\t\t// We call a mutation to commit our response data\n\t\t\t\tcommit(\"SUCCESS\", response.data);\n\t\t\t});\n\t},\n\n\t// This action is used to make a get request to get list of trendingPolls from the server\n\tgetTrendingPolls({ commit, getters }) {\n\t\tlet config = {\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Token ${getters.getToken}`\n\t\t\t}\n\t\t};\n\t\taxios\n\t\t\t.get(`${apiBaseUrl.baseRoute}/trending/polls/`, config)\n\t\t\t.then(response => {\n\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t\t\t\t// We call a mutation to commit our response data\n\t\t\t\tcommit(\"TRENDING_POLLS\", response.data);\n\t\t\t});\n\t},\n\t// getTrendingFeeds({ commit, getters }) {\n\t// \tlet config = {\n\t// \t\theaders: {\n\t// \t\t\tAuthorization: `Token ${getters.getToken}`\n\t// \t\t\t// \"Content-Type\": \"application/json\"\n\t// \t\t}\n\t// \t};\n\t// \taxios\n\t// \t\t.get(`${apiBaseUrl.baseRoute}/trending/feed/`, config)\n\t// \t\t.then(response => {\n\t// \t\t\tconsole.log(response.data, \"FROM TRENDING Feeds\");\n\t// \t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t// \t\t\tcommit(\"SUCCESS\", response.data);\n\t// \t\t});\n\t// },\n\n\t// This action is used to make a post request to search for an existing poll\n\tsearchPolls({ commit, getters }, payload) {\n\t\tlet config = {\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Token ${getters.getToken}`\n\t\t\t}\n\t\t};\n\t\taxios\n\t\t\t.get(`${apiBaseUrl.baseRoute}/search/poll/?search=` + payload, config)\n\t\t\t.then(response => {\n\t\t\t\tconsole.log(response.data, \"SEARCH RESULT\");\n\t\t\t\taxios.defaults.headers.common[\"Authorization\"] = config;\n\t\t\t\t// We call a mutation to commit our response data\n\t\t\t\tcommit(\"SEARCH_RESULT\", response.data);\n\t\t\t});\n\t}\n};\n\n// These are used to update our state depending on the response gotten when an action is dispatched\nconst mutations = {\n\tauth_request(state) {\n\t\tstate.status = \"loading\";\n\t},\n\tregistration_success(state, payload) {\n\t\t// const { username, email, ...profile} = payload\n\t\t// state.user\n\t},\n\tauth_success(state, payload) {\n\t\tconst { token, pk } = payload;\n\t\tstate.status = \"success\";\n\t\tstate.loggedIn = true;\n\t\tstate.token = token;\n\t\tstate.userID = pk;\n\t},\n\tauth_error(state, payload) {\n\t\tconst { data } = payload;\n\t\tstate.status = \"error\";\n\t\tstate.isLoading = false;\n\t\tstate.error = data;\n\t},\n\tlogout(state) {\n\t\tstate.status = \"\";\n\t\tstate.token = \"\";\n\t},\n\n\t/* Used to update the states which are perculiar for display data specific to a user or userprofile\n\tSince the the payload contains a user object, while destructing the payload, we use spread operator\n\tto get the keys in the user object */\n\tfetch_users(state, payload) {\n\t\tconst { followed, followers, likes, polls, ...user } = payload;\n\t\tstate.user.userObj = user;\n\t\tstate.user.followed = followed;\n\t\tstate.user.followers = followers;\n\t\tstate.user.polls = polls;\n\t\tstate.user.likes = likes;\n\t},\n\n\t// this simply updates the Polls data in the state with the data coming from the payload\n\tSUCCESS: (state, payload) => (state.Polls = payload),\n\tSINGLE_POLL: (state, payload) => {\n\t\tconst {\n\t\t\tid,\n\t\t\tpub_date,\n\t\t\tquestion,\n\t\t\tpoller_username,\n\t\t\tchoice_type,\n\t\t\texpire_date,\n\t\t\tslug_field,\n\t\t\tpoll_has_been_bookmarked,\n\t\t\tpoll_has_been_liked,\n\t\t\ttotal_likes,\n\t\t\tvote_count,\n\t\t\t...choices\n\t\t} = payload;\n\t\tstate.SinglePoll.id = id;\n\t\tstate.SinglePoll.pub_date = pub_date;\n\t\tstate.SinglePoll.question = question;\n\t\tstate.SinglePoll.poller_username = poller_username;\n\t\tstate.SinglePoll.choice_type = choice_type;\n\t\tstate.SinglePoll.expire_date = expire_date;\n\t\tstate.SinglePoll.slug_field = slug_field;\n\t\tstate.SinglePoll.poll_has_been_bookmarked = poll_has_been_bookmarked;\n\t\tstate.SinglePoll.poll_has_been_liked = poll_has_been_liked;\n\t\tstate.SinglePoll.total_likes = total_likes;\n\t\tstate.SinglePoll.vote_count = vote_count;\n\t\tstate.SinglePoll.choices = { ...choices };\n\t},\n\n\tTRENDING_POLLS: (state, payload) => {\n\t\t/* Since we are getting a list of items from the API which contains repeated questions, we filter out\n\t\tthis repeated question using javascript Set method and loop over the incoming date to fetch only the\n\t\tquestions which we then store in the filteredList variable. Next we use the spread operator on our set of questions,\n\t\tconverting it into a list and pass it to the state.trendingPolls to be updated in the state */\n\t\tlet filteredList = new Set(payload.map(poll => poll.question));\n\t\tstate.trendingPolls = [...filteredList];\n\t}\n};\n\n/* \n\tGoing forward the config variable can be used as a helper function to avoid repeating same codes whenever\n\tyou want to make a request to an endpoint that is restricted\n\n\tconst config = {\n\t\theaders: {\n\t\t\t: `Token ${getters.getToken}`\n\t\t \t\"Content-Type\": \"application/json\"\n\t\t}\n\t}; \n*/\n\nexport default {\n\tstate,\n\tgetters,\n\tactions,\n\tmutations\n\t// config\n};\n"]}]}